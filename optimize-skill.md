# 优先使用v-if

> v-if 和 v-show 理论上都是作用于元素的显示隐藏，只是一个是直接对DOM，一个是通过CSS的display来操作的，在项目中大部分的时候我们都是直接使用 v-if 直接代替使用 v-show，只有当DOM频繁进行先和隐藏的时候，但是这种场景非常少见。

#  v-for 和 v-if 不要一起使用

> v-for 的优先级其实比 v-if 高的，所以当两个指令出现来一个DOM中，那么 v-for 渲染的当前列表，每一次都需要进行一次 v-if 的判断。而相应的列表也会重新变化，这看起来是非常合理的，因此当你需要进行同步只能的时候。尽量使用计算属性，现将 v-if 不需要的值先过滤掉。

# v-for 和 key 避免使用 index 作为标识符

> 其实大家都知道 v-for 是不推荐使用 index 下标作为 key 的值， 这是一个非常好理解的知识点，可以从图中看到， 当 index 作为标识的时候，插入一条数据的时候，列表中它后面的 key 都发生了变化，那么当前的 v-for 都会对 key 变化的 element 重新渲染，但是其实它们除了插入的 element 数据都是没有发生改变，这就导致了没有必要的开销。所以，尽量不要使用 index 作为标识，而采用数据中的唯一值，如 id 等字段

# 释放组件资源

> 什么是资源？每创建出一个事物都需要消耗资源， 资源不是凭空产生的，是分配出来的。所以说，当组件销毁后，尽量把我们开辟出来的 资源块给销毁掉，比如 setInterval， addEventListener 等，如果不去手动释放掉，那么它们就会一直占用一部分资源，这就导致了没有必要的资源浪费。多来几次后，可以想象一下资源占用率肯定是上升的。

# 长列表

> 项目当中，会涉及到非常多的长列表场景，区别于普通的分页来说，大部分的前端在做这种无限列表的时候，大部分新手前端都是通过 v-for 将数据遍历出来，想的多一点的就是做一个分页。滚动到底部的时候就继续请求API。其实这也是未思考妥当的。随着数据的加载，DOM会越来越多，这样就导致了性能开销的问题产生了，当页面上的DOM太多的时候，难免给我的客户端造成一定的压力，所以对于长列表渲染的时候，建议将DOM移除掉，类似于图片懒加载的模式，只有出现在视图上的DOM才是重要的DOM。网络上有一些很好的解决方案，如 vue-virtual-scroller库等等，大家可以理解性的选择。

# 图片合理的优化方式

> 在网页中，往往存在大量的图片资源，这些资源或大或小。当我们页面中DOM中存在大量的图片时，难免不会碰到一些加载缓慢的问题，导致图片出现加载失败的问题。网络上大部分都在使用懒加载的使用方式，只有当存在图片的DOM出现在页面上才会进行图片的加载，无形中起到了分流的作用，以下是一套实践的方案：

* 小图标使用SVG或者字体图标
* 通过base64和webp的方式加载小型图片
* 能通过CDN加速的大图尽量CDN
* 大部分框架都带有懒加载图片，不要嫌麻烦，多花点时间使用它

# 路由按需加载

> 对于路由的懒加载有两种方式，一种是 require，另一种是 improt。当路由按需加载后，那么Vue服务在第一次加载时的压力就能够相应的小一下，不会出现超长白屏P0问题。下面是两种路由懒加载的写法：

```js
const routes = [
  // webpack < 2.4
  {
    path: '/',
    name: 'home',
    components: resolve => require(['@/views/home'], resolve)
  },
  // webpack > 2.4
  {
    path: '/',
    name: 'home',
    components: () => import('@/views/home')
  }
]
```

# UI框架使用方式

> 确保在使用UI框架如，vant, nut等UI框架的时候，都使用官方给暴露出来的按需加载组件。只有真正用到它的时候才会加载当前UI框架的组件，而不是一开始就讲整个组件库给加载出来。所以建议尽量的使用按需加载。合理的对项目进行止损。

```js
import {Button} from 'vant'
```

# 首屏优化

> 第一次打开Vue项目的时候，如果项目够大，那么首次加载资源时，会非常的久。由于资源没有加载完毕，界面的DOM也不会渲染，会造成白屏的问题，用户此时并不知道是加载的问题，所以会带来一个不好的体验。通常会做一个加载动画或骨架屏，告诉用户，网页在夹杂中这个提示。当页面加载成功后，页面渲染出来的这一个体验比白屏等开机要好太多。


# 最小化JS文件

> 可以通过webpack处理打包的JS文件，让其更加的精简。在配置中，你可以这么做

```js
  config.optimization.minimize(true);
```

# 图片资源压缩

> 可以通过 image-webpack-loader 插件对打包的图片进行压缩，看起来会对图片的加载有一下提升。如果担心破坏图片，可以放弃使用它。

```js
config.module
  .rule('images')
  .use('image-webpack-loader')
  .loader('image-webpack-loader')
  .options({
    bypassOnDebug: true
  })
  .end()
```

# 打包公共代码

> 在webpack4中，可以通过 optimization.minimize 将公共代码进行打包，虽然我个人认为这个东西对SPA应用来说，效果其实有限，但有胜与无，文字再小也是肉。

```js
new webpack.optimize.CommonsChunkPlugin({
  name: ['vendor','runtime'],
  filename: '[xxxxx].js'
})
```

# 删除沉淀代码

> 使用 Tree-Shaking 插件可以将一些无用的沉淀泥沙代码给清理掉。

# 依赖库DCN加速

> 将Vue、Axios、Echarts 等都分离出来，在正式环境下，通过CDN，确实有了一下明显的提升。

```js
    // 在html引入script标签后。在vue的配置中，进行声明
    
    configureWebpack: {
        externals: {
        'echarts': 'echarts' // 配置使用CDN
        }
    } 
```

# GZIP

> 这个需要服务器进行配置
